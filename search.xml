<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Spring Async多线程使用]]></title>
      <url>/my-blog/2019/08/20/Spring-Async%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文记录Spring Async对Java多线程的支持</p>
<a id="more"></a>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Java在处理多线程时需要用到线程池及其相关的API,配置较为零散,学习成本较高.Spring提供了便捷的配置类来支持多线程的实现.</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>Java多线程</li>
<li>Spring Async</li>
</ul>
<h3 id="Spring-Async配置类"><a href="#Spring-Async配置类" class="headerlink" title="Spring Async配置类"></a>Spring Async配置类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开启多线程操作，注解方式</span><br><span class="line"> * 在需要进行异步处理的方法上加上@Async注解</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAsync</span><br><span class="line">public class AsyncConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置线程池基本大小值, 线程池维护线程的最少数量</span><br><span class="line">     */</span><br><span class="line">    private int corePoolSize = 10;</span><br><span class="line">    /**</span><br><span class="line">     * 设置线程池最大值</span><br><span class="line">     */</span><br><span class="line">    private int maxPoolSize = 200;</span><br><span class="line">    /**</span><br><span class="line">     * 线程池所使用的缓冲队列大小</span><br><span class="line">     */</span><br><span class="line">    private int queueCapacity = 1024;</span><br><span class="line">    /**</span><br><span class="line">     * 配置线程最大空闲时间</span><br><span class="line">     */</span><br><span class="line">    private int keepAliveSeconds = 50000;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Executor asyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;AsyncExecutor-&quot;);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * rejection-policy：当pool已经达到max size的时候，如何处理新任务</span><br><span class="line">         * CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行</span><br><span class="line">         */</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Async服务类-控制层"><a href="#Spring-Async服务类-控制层" class="headerlink" title="Spring Async服务类-控制层"></a>Spring Async服务类-控制层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import org.eureka.service.impl.AsyncService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description: 异步任务测试类</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AsyncService asyncService;</span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)</span><br><span class="line">    public String testAsyncNoRetrun()&#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">         asyncService.doNoReturn();</span><br><span class="line">         return String.format(&quot;任务执行成功,耗时&#123;%s&#125;&quot;, System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hi&quot;)</span><br><span class="line">    public Map&lt;String, Object&gt; testAsyncReturn() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Future&lt;String&gt; future = asyncService.doReturn(i);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 读取的时候,记得要批量读取不能单独读取,否则无法实现异步的效果</span><br><span class="line">         * 且需要注意:</span><br><span class="line">         * 异步方法和调用类不要在同一个类中</span><br><span class="line">         */</span><br><span class="line">        List&lt;String&gt; response = new ArrayList&lt;&gt;();</span><br><span class="line">        for (Future future : futures) &#123;</span><br><span class="line">            String string = (String) future.get();</span><br><span class="line">            response.add(string);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(&quot;data&quot;, response);</span><br><span class="line">        map.put(&quot;消耗时间&quot;, String.format(&quot;任务执行成功,耗时&#123;%s&#125;毫秒&quot;, System.currentTimeMillis() - start));</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Async服务类-实现层"><a href="#Spring-Async服务类-实现层" class="headerlink" title="Spring Async服务类-实现层"></a>Spring Async服务类-实现层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.scheduling.annotation.Async;</span><br><span class="line">import org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description: 异步任务测试类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class AsyncService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 处理无返回的异步任务</span><br><span class="line">     * @param</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws</span><br><span class="line">     * @date 2019/8/20 16:34</span><br><span class="line">     **/</span><br><span class="line">    @Async</span><br><span class="line">    public void doNoReturn()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这个方法执行需要三秒</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            System.out.println(&quot;方法执行结束&quot; + new Date());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 处理有返回的异步任务</span><br><span class="line">     * @param i</span><br><span class="line">     * @return java.util.concurrent.Future&lt;java.lang.String&gt;</span><br><span class="line">     * @throws</span><br><span class="line">     * @date 2019/8/20 16:35</span><br><span class="line">     **/</span><br><span class="line">    @Async</span><br><span class="line">    public Future&lt;String&gt; doReturn(int i)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这个方法需要调用500毫秒</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        // 消息汇总</span><br><span class="line">        return new AsyncResult&lt;&gt;(String.format(&quot;这个是第&#123;%s&#125;个异步调用的证书&quot;, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Async </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mongoDB结构文档多层次查询及更新]]></title>
      <url>/my-blog/2019/08/20/mongoDB%E7%BB%93%E6%9E%84%E6%96%87%E6%A1%A3%E5%A4%9A%E5%B1%82%E6%AC%A1%E6%9F%A5%E8%AF%A2%E5%8F%8A%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>本文记录Spring Data Mongodb中对mongoDB查询及更新的实现.</p>
<a id="more"></a>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>mongoDB中文档会具有较深的深度,在通过mongoTemplate进行处理时,需要注意使用的语法.本文介绍两种场景:深层次查询及更新</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>mongoDB语法</li>
<li>mongoTemplate接口API</li>
</ul>
<h3 id="mongoDB文档展示"><a href="#mongoDB文档展示" class="headerlink" title="mongoDB文档展示"></a>mongoDB文档展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5d5684ae1599021e848d6736&quot;),</span><br><span class="line">    &quot;vehicleId&quot; : &quot;AP_4028b2b64fb20697014fdf7f65e44346&quot;,</span><br><span class="line">    &quot;list&quot; : [ </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;groupName&quot; : &quot;发动机系统&quot;,</span><br><span class="line">            &quot;groupCode&quot; : &quot;1000&quot;,</span><br><span class="line">            &quot;programs&quot; : &#123;</span><br><span class="line">                &quot;vehicleId&quot; : &quot;AP_4028b2b64fb20697014fdf7f65e44346&quot;,</span><br><span class="line">                &quot;groupCode&quot; : &quot;1000&quot;,</span><br><span class="line">                &quot;list&quot; : [ </span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;baseItemName&quot; : &quot;清洗喷油嘴&quot;,</span><br><span class="line">                        &quot;baseItemCode&quot; : &quot;QX040001&quot;,</span><br><span class="line">                        &quot;itemDesc&quot; : &quot;20000km或24个月/次&quot;,</span><br><span class="line">                        &quot;judge&quot; : &quot;1&quot;</span><br><span class="line">                    &#125;, </span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;baseItemName&quot; : &quot;润滑系统清洁养护&quot;,</span><br><span class="line">                        &quot;baseItemCode&quot; : &quot;QX010001&quot;,</span><br><span class="line">                        &quot;itemDesc&quot; : &quot;5000km/次&quot;,</span><br><span class="line">                        &quot;judge&quot; : &quot;0&quot;</span><br><span class="line">                    &#125;, </span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;baseItemName&quot; : &quot;清洗节气门&quot;,</span><br><span class="line">                        &quot;baseItemCode&quot; : &quot;QX020001&quot;,</span><br><span class="line">                        &quot;itemDesc&quot; : &quot;20000km或24个月/次&quot;,</span><br><span class="line">                        &quot;judge&quot; : &quot;0&quot;</span><br><span class="line">                    &#125;, </span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;baseItemName&quot; : &quot;清洗进气系统&quot;,</span><br><span class="line">                        &quot;baseItemCode&quot; : &quot;QX010002&quot;,</span><br><span class="line">                        &quot;itemDesc&quot; : &quot;20000km/次&quot;,</span><br><span class="line">                        &quot;judge&quot; : &quot;0&quot;</span><br><span class="line">                    &#125;, </span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;baseItemName&quot; : &quot;火花塞&quot;,</span><br><span class="line">                        &quot;baseItemCode&quot; : &quot;BY036055&quot;,</span><br><span class="line">                        &quot;judge&quot; : &quot;0&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;groupName&quot; : &quot;常规保养&quot;,</span><br><span class="line">            &quot;groupCode&quot; : &quot;6000&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;_class&quot; : &quot;MaintenanceClassificationRespResult&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现代码-深层次查询"><a href="#实现代码-深层次查询" class="headerlink" title="实现代码:深层次查询"></a>实现代码:深层次查询</h3><p>深层次查询(方式一):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过构造函数andOperator()连接and条件,通过elemMatch()指定子级节点</span><br><span class="line">Query query = Query.query(new Criteria().andOperator(Criteria.where(&quot;vehicleId&quot;).is(vehicleId), Criteria.where(&quot;list&quot;).elemMatch(Criteria.where(&quot;groupCode&quot;).is(groupCode))));</span><br><span class="line"></span><br><span class="line">// findOne()仅返回匹配的第一个文档,此处需注意返回的为整个文档,若需要指定返回内容,需要使用原生API,findOne()第三个入参为文档表名</span><br><span class="line">MaintenanceClassificationRespResult result = mongoTemplate.findOne(query, MaintenanceClassificationRespResult.class, IEasyepcCode.EASYEPC_MONGODB_325021_325031);</span><br></pre></td></tr></table></figure>

<p>深层次查询(方式二):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过.的形式指定子级节点</span><br><span class="line">Query query = new Query(Criteria.where(&quot;vehicleId&quot;).is(vehicleId).and(&quot;list.groupCode&quot;).is(groupCode));</span><br></pre></td></tr></table></figure>

<p>深层次查询(方式三):</p>
<p>此处可以参考博文:<a href="https://blog.csdn.net/congcong68/column/info/15995" target="_blank" rel="noopener">学习MongoDB 四:MongoDB查询</a></p>
<h3 id="实现代码-深层次更新"><a href="#实现代码-深层次更新" class="headerlink" title="实现代码:深层次更新"></a>实现代码:深层次更新</h3><p>深层次更新:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void updateJudgeForMaintenanceClassificationList(String vehicleId, String groupCode, String baseItemCode) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 由于MongoDB不支持多层占位(.$.)更新,所以需要通过代码逻辑确认第一层数组下标</span><br><span class="line">     * 需要先查询原两层结构</span><br><span class="line">     * updateFirst()第三个入参为文档表名</span><br><span class="line">     */</span><br><span class="line">    MaintenanceClassificationRespResult tempResult = queryMaintenanceClassificationByMongoDB(MaintenanceClassificationReqModel</span><br><span class="line">            .builder().vehicleId(vehicleId).build());</span><br><span class="line">    if (!Objects.isNull(tempResult)) &#123;</span><br><span class="line">        List&lt;MaintenanceClassificationRespList&gt; list = tempResult.getList();</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            MaintenanceClassificationRespList data = list.get(i);</span><br><span class="line">            if (groupCode.equals(data.getGroupCode())) &#123;</span><br><span class="line">                // 保养项目分类一致,更新其下保养项目明细</span><br><span class="line">                Query query = Query.query(new Criteria().andOperator(Criteria.where(&quot;vehicleId&quot;).is(vehicleId)</span><br><span class="line">                        , Criteria.where(&quot;list.programs.list.baseItemCode&quot;).is(baseItemCode)));</span><br><span class="line">                Update update = new Update();</span><br><span class="line">                update.set(&quot;list.&quot; + i + &quot;.programs.list.$.judge&quot;, IEasyepcCode.JUDGE_1);</span><br><span class="line">                UpdateResult updateResult = mongoTemplate.updateFirst(query, update, IEasyepcCode.EASYEPC_MONGODB_325021_325031);</span><br><span class="line">                log.info(&quot;mongoDB更新文档结果:&#123;&#125;&quot;, updateResult.toString());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>Spring Data Mongodb默认不开启事务,若果需要开启,可以参考<a href="https://blog.csdn.net/zhang135123/article/details/86571278" target="_blank" rel="noopener">Spring Data Mongodb事务管理</a></p>
]]></content>
      
        <categories>
            
            <category> Mongodb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mongodb </tag>
            
            <tag> Spring Data Mongodb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[List结构数据组装成树结构实现方式]]></title>
      <url>/my-blog/2019/08/19/List%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E7%BB%84%E8%A3%85%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文记录List结构数据组装成树结构实现.</p>
<a id="more"></a>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>通过查询数据库中具有父子关系的结构数据,将获得的List数据转换为Tree结构的数据,一般用于前端多级树展示</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>递归</li>
<li>双层for循环</li>
<li>高速缓存Map</li>
</ul>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">	&quot;id&quot;: &quot;1&quot;,</span><br><span class="line">	&quot;name&quot;: &quot;广州&quot;,</span><br><span class="line">	&quot;parentId&quot;: &quot;0&quot;,</span><br><span class="line">	&quot;children&quot;: [&#123;</span><br><span class="line">		&quot;id&quot;: &quot;3&quot;,</span><br><span class="line">		&quot;name&quot;: &quot;天河区&quot;,</span><br><span class="line">		&quot;parentId&quot;: &quot;1&quot;,</span><br><span class="line">		&quot;children&quot;: [&#123;</span><br><span class="line">			&quot;id&quot;: &quot;6&quot;,</span><br><span class="line">			&quot;name&quot;: &quot;石牌&quot;,</span><br><span class="line">			&quot;parentId&quot;: &quot;3&quot;,</span><br><span class="line">			&quot;children&quot;: [&#123;</span><br><span class="line">				&quot;id&quot;: &quot;7&quot;,</span><br><span class="line">				&quot;name&quot;: &quot;百脑汇&quot;,</span><br><span class="line">				&quot;parentId&quot;: &quot;6&quot;</span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		&quot;id&quot;: &quot;4&quot;,</span><br><span class="line">		&quot;name&quot;: &quot;越秀区&quot;,</span><br><span class="line">		&quot;parentId&quot;: &quot;1&quot;</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		&quot;id&quot;: &quot;5&quot;,</span><br><span class="line">		&quot;name&quot;: &quot;黄埔区&quot;,</span><br><span class="line">		&quot;parentId&quot;: &quot;1&quot;</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	&quot;id&quot;: &quot;2&quot;,</span><br><span class="line">	&quot;name&quot;: &quot;深圳&quot;,</span><br><span class="line">	&quot;parentId&quot;: &quot;0&quot;,</span><br><span class="line">	&quot;children&quot;: [&#123;</span><br><span class="line">		&quot;id&quot;: &quot;8&quot;,</span><br><span class="line">		&quot;name&quot;: &quot;南山区&quot;,</span><br><span class="line">		&quot;parentId&quot;: &quot;2&quot;,</span><br><span class="line">		&quot;children&quot;: [&#123;</span><br><span class="line">			&quot;id&quot;: &quot;10&quot;,</span><br><span class="line">			&quot;name&quot;: &quot;科技园&quot;,</span><br><span class="line">			&quot;parentId&quot;: &quot;8&quot;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		&quot;id&quot;: &quot;9&quot;,</span><br><span class="line">		&quot;name&quot;: &quot;宝安区&quot;,</span><br><span class="line">		&quot;parentId&quot;: &quot;2&quot;</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>树节点定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.annotation.JSONType;</span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TODO 树节点</span><br><span class="line"> *</span><br><span class="line"> * @date 2019/8/19 17:54</span><br><span class="line"> **/</span><br><span class="line">@Data</span><br><span class="line">@JSONType(orders = &#123;&quot;id&quot;,&quot;name&quot;,&quot;parentId&quot;,&quot;children&quot;&#125;)</span><br><span class="line">public class TreeNode implements Serializable&#123;</span><br><span class="line">    private String id;</span><br><span class="line"></span><br><span class="line">    private String parentId;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private List&lt;TreeNode&gt; children;</span><br><span class="line"></span><br><span class="line">    public TreeNode(String id, String name, String parentId) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.parentId = parentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode(String id, String name, TreeNode parent) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.parentId = parent.getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode(TreeNode node) &#123;</span><br><span class="line">        this.id = node.getId();</span><br><span class="line">        this.name = node.getName();</span><br><span class="line">        this.parentId = node.getParentId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树组装类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TODO 树构造器</span><br><span class="line"> *</span><br><span class="line"> * @date 2019/8/19 17:55</span><br><span class="line"> **/</span><br><span class="line">public class TreeBuilder &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 双层循环实现建树,对传入的树节点列表无排序要求</span><br><span class="line">     * @param treeNodes 传入的树节点列表</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;TreeNode&gt; bulidByLoop(List&lt;TreeNode&gt; treeNodes) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;TreeNode&gt; trees = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        for (TreeNode treeNode : treeNodes) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 根节点的父Id为0,且不要求仅有唯一的根</span><br><span class="line">              */</span><br><span class="line">            if (&quot;0&quot;.equals(treeNode.getParentId())) &#123;</span><br><span class="line">                trees.add(treeNode);</span><br><span class="line">            &#125;</span><br><span class="line">            for (TreeNode it : treeNodes) &#123;</span><br><span class="line">                if (it.getParentId() == treeNode.getId()) &#123;</span><br><span class="line">                    if (treeNode.getChildren() == null) &#123;</span><br><span class="line">                        treeNode.setChildren(new ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                    treeNode.getChildren().add(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return trees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 使用递归方法建树,对传入的树节点列表无排序要求</span><br><span class="line">     * @param treeNodes</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;TreeNode&gt; buildByRecursive(List&lt;TreeNode&gt; treeNodes) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; trees = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        for (TreeNode treeNode : treeNodes) &#123;</span><br><span class="line">            // 根节点的父Id为0,且不要求仅有唯一的根</span><br><span class="line">            if (&quot;0&quot;.equals(treeNode.getParentId())) &#123;</span><br><span class="line">                trees.add(findChildren(treeNode,treeNodes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return trees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 递归查找子节点</span><br><span class="line">     * @param treeNodes</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static TreeNode findChildren(TreeNode treeNode,List&lt;TreeNode&gt; treeNodes) &#123;</span><br><span class="line">        for (TreeNode it : treeNodes) &#123;</span><br><span class="line">            if(treeNode.getId().equals(it.getParentId())) &#123;</span><br><span class="line">                if (treeNode.getChildren() == null) &#123;</span><br><span class="line">                    treeNode.setChildren(new ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                treeNode.getChildren().add(findChildren(it,treeNodes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return treeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 通过Map缓存生成树</span><br><span class="line">     * @param dataList 经过排序的集合,要求父节点必须位于集合第一个元素,且仅能存在唯一的根节点</span><br><span class="line">     * @return tree.TreeNode</span><br><span class="line">     **/</span><br><span class="line">    public static TreeNode bulidByMapLink(List&lt;TreeNode&gt; dataList) &#123;</span><br><span class="line">        if (null == dataList || 0 == dataList.size()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 节点缓存</span><br><span class="line">        Map&lt;String, TreeNode&gt; linkTree = new HashMap&lt;String, TreeNode&gt;();</span><br><span class="line">        TreeNode temp = new TreeNode(dataList.get(0));</span><br><span class="line">        // 缓存树结构</span><br><span class="line">        linkTree.put(temp.getId(), temp);</span><br><span class="line">        // 遍历数据除首条外的数据，建立节点关联关系</span><br><span class="line">        for (int i = 1; i &lt; dataList.size(); i++) &#123;</span><br><span class="line">            TreeNode node = new TreeNode(dataList.get(i));</span><br><span class="line">            if (null != linkTree.get(dataList.get(i).getParentId())) &#123;</span><br><span class="line">                // 缓存中已存在相关父节点,子节点</span><br><span class="line">                if (null == linkTree.get(dataList.get(i).getParentId()).getChildren()) &#123;</span><br><span class="line">                    // 缓存中子节点不存在</span><br><span class="line">                    linkTree.get(dataList.get(i).getParentId()).setChildren(new ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                linkTree.get(dataList.get(i).getParentId()).getChildren().add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            linkTree.put(node.getId(), node);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode reTree = linkTree.get(temp.getId());</span><br><span class="line">        linkTree.clear();</span><br><span class="line">        return reTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 为双层循环,递归方法实现建树组装集合</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.util.List&lt;tree.TreeNode&gt;</span><br><span class="line">     * @date 2019/8/20 10:44</span><br><span class="line">     **/</span><br><span class="line">    public static List&lt;TreeNode&gt; initList()&#123;</span><br><span class="line">        TreeNode treeNode1 = new TreeNode(&quot;1&quot;,&quot;广州&quot;,&quot;0&quot;);</span><br><span class="line">        TreeNode treeNode2 = new TreeNode(&quot;2&quot;,&quot;深圳&quot;,&quot;0&quot;);</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode3 = new TreeNode(&quot;3&quot;,&quot;天河区&quot;,treeNode1);</span><br><span class="line">        TreeNode treeNode4 = new TreeNode(&quot;4&quot;,&quot;越秀区&quot;,treeNode1);</span><br><span class="line">        TreeNode treeNode5 = new TreeNode(&quot;5&quot;,&quot;黄埔区&quot;,treeNode1);</span><br><span class="line">        TreeNode treeNode6 = new TreeNode(&quot;6&quot;,&quot;石牌&quot;,treeNode3);</span><br><span class="line">        TreeNode treeNode7 = new TreeNode(&quot;7&quot;,&quot;百脑汇&quot;,treeNode6);</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode8 = new TreeNode(&quot;8&quot;,&quot;南山区&quot;,treeNode2);</span><br><span class="line">        TreeNode treeNode9 = new TreeNode(&quot;9&quot;,&quot;宝安区&quot;,treeNode2);</span><br><span class="line">        TreeNode treeNode10 = new TreeNode(&quot;10&quot;,&quot;科技园&quot;,treeNode8);</span><br><span class="line"></span><br><span class="line">        List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        list.add(treeNode1);</span><br><span class="line">        list.add(treeNode2);</span><br><span class="line">        list.add(treeNode3);</span><br><span class="line">        list.add(treeNode4);</span><br><span class="line">        list.add(treeNode5);</span><br><span class="line">        list.add(treeNode6);</span><br><span class="line">        list.add(treeNode7);</span><br><span class="line">        list.add(treeNode8);</span><br><span class="line">        list.add(treeNode9);</span><br><span class="line">        list.add(treeNode10);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 为通过Map缓存实现建树组装集合</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.util.List&lt;tree.TreeNode&gt;</span><br><span class="line">     * @date 2019/8/20 10:45</span><br><span class="line">     **/</span><br><span class="line">    public static List&lt;TreeNode&gt; initListByMapLink()&#123;</span><br><span class="line">        TreeNode treeNode0_t = new TreeNode(&quot;0&quot;,&quot;中国&quot;,&quot;-1&quot;);</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode1_t = new TreeNode(&quot;1&quot;,&quot;广州&quot;,treeNode0_t);</span><br><span class="line">        TreeNode treeNode2_t = new TreeNode(&quot;2&quot;,&quot;深圳&quot;,treeNode0_t);</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode3_t = new TreeNode(&quot;3&quot;,&quot;天河区&quot;,treeNode1_t);</span><br><span class="line">        TreeNode treeNode4_t = new TreeNode(&quot;4&quot;,&quot;越秀区&quot;,treeNode1_t);</span><br><span class="line">        TreeNode treeNode5_t = new TreeNode(&quot;5&quot;,&quot;黄埔区&quot;,treeNode1_t);</span><br><span class="line">        TreeNode treeNode6_t = new TreeNode(&quot;6&quot;,&quot;石牌&quot;,treeNode3_t);</span><br><span class="line">        TreeNode treeNode7_t = new TreeNode(&quot;7&quot;,&quot;百脑汇&quot;,treeNode6_t);</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode8_t = new TreeNode(&quot;8&quot;,&quot;南山区&quot;,treeNode2_t);</span><br><span class="line">        TreeNode treeNode9_t = new TreeNode(&quot;9&quot;,&quot;宝安区&quot;,treeNode2_t);</span><br><span class="line">        TreeNode treeNode10_t = new TreeNode(&quot;10&quot;,&quot;科技园&quot;,treeNode8_t);</span><br><span class="line"></span><br><span class="line">        List&lt;TreeNode&gt; list_t = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        list_t.add(treeNode0_t);</span><br><span class="line">        list_t.add(treeNode1_t);</span><br><span class="line">        list_t.add(treeNode2_t);</span><br><span class="line">        list_t.add(treeNode3_t);</span><br><span class="line">        list_t.add(treeNode4_t);</span><br><span class="line">        list_t.add(treeNode5_t);</span><br><span class="line">        list_t.add(treeNode6_t);</span><br><span class="line">        list_t.add(treeNode7_t);</span><br><span class="line">        list_t.add(treeNode8_t);</span><br><span class="line">        list_t.add(treeNode9_t);</span><br><span class="line">        list_t.add(treeNode10_t);</span><br><span class="line">        return list_t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBulidByLoop()&#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeNodes = initList();</span><br><span class="line">        List&lt;TreeNode&gt; trees_0 = TreeBuilder.bulidByLoop(treeNodes);</span><br><span class="line">        // 指定Json转换时保持Key顺序,Key顺序由@JSONType(orders)指定</span><br><span class="line">        System.out.println(&quot;trees[0]:&quot;+ JSONObject.toJSONString(trees_0, SerializerFeature.SortField));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBulidByRecursive()&#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeNodes = initList();</span><br><span class="line">        List&lt;TreeNode&gt; trees_1 = TreeBuilder.buildByRecursive(treeNodes);</span><br><span class="line">        System.out.println(&quot;trees[1]:&quot;+ JSONObject.toJSONString(trees_1, SerializerFeature.SortField));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBulidByMapLink()&#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeNodes = initListByMapLink();</span><br><span class="line">        TreeNode trees_2 = TreeBuilder.bulidByMapLink(treeNodes);</span><br><span class="line">        System.out.println(&quot;trees[2]:&quot;+ JSONObject.toJSONString(trees_2, SerializerFeature.SortField));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring AOP日志记录实现]]></title>
      <url>/my-blog/2019/08/19/Spring-AOP%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>本文记录Spring AOP日志记录实现.</p>
<a id="more"></a>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>通过切面编程,为Rest请求记录入参及回参的日志,同时对于整合链路跟踪的项目,记录请求Trace信息</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>@Aspect及其派生的注解使用</li>
<li>获取实际客户端Ip工具类</li>
<li>链路跟踪相关工具类</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>链路跟踪Pom依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 链路跟踪模块 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>日志记录切面类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">import brave.Span;</span><br><span class="line">import brave.Tracer;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.context.request.RequestAttributes;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">/**</span><br><span class="line"> * TODO 日志记录切面类</span><br><span class="line"> **/</span><br><span class="line">@Component</span><br><span class="line">@Aspect </span><br><span class="line">@Slf4j</span><br><span class="line">public class LoggerAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Tracer tracer;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 指定切点位置,主要针对RestController及Controller修饰的对外接口</span><br><span class="line">     * @param</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws</span><br><span class="line">     * @date 2019/8/19 16:45</span><br><span class="line">     **/</span><br><span class="line">    @Pointcut(&quot;@within(org.springframework.web.bind.annotation.RestController) || @within(org.springframework.stereotype.Controller)&quot;)</span><br><span class="line">    public void annotationController() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 此处使用环绕注解,通过joinPoint.proceed()获取返回结果,需要注意点为异常处理</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     * @return java.lang.Object</span><br><span class="line">     * @throws</span><br><span class="line">     * @date 2019/8/19 16:47</span><br><span class="line">     **/</span><br><span class="line">    @Around(value = &quot;annotationController()&quot;)</span><br><span class="line">    public Object showBeginLog(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 开始时间</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        String traceId = null;</span><br><span class="line">        Object result = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">            if (requestAttributes instanceof ServletRequestAttributes) &#123;</span><br><span class="line">                ServletRequestAttributes servletRa = (ServletRequestAttributes) requestAttributes;</span><br><span class="line">                if (Objects.nonNull(servletRa)) &#123;</span><br><span class="line">                    traceId = extractTraceId(this.tracer);</span><br><span class="line">                    HttpServletRequest request = servletRa.getRequest();</span><br><span class="line">                    StringBuffer requestURL = request.getRequestURL();</span><br><span class="line">                    String requestURI = request.getRequestURI();</span><br><span class="line">                    String method = request.getMethod();</span><br><span class="line">                    String ipAddress = getIpAddr(request);</span><br><span class="line"></span><br><span class="line">                    //封装入参Request列表</span><br><span class="line">                    Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">                    // 封装入参Body列表</span><br><span class="line">                    String requestStr = getRequestParam(joinPoint);</span><br><span class="line">                    requestStr = parameterHandle(requestStr, 10000);</span><br><span class="line"></span><br><span class="line">                    // url</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求的url=&#123;&#125;&quot;, traceId, requestURL);</span><br><span class="line">                    // uri</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求的uri=&#123;&#125;&quot;, traceId, requestURI);</span><br><span class="line">                    // method</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求method=&#123;&#125;&quot;, traceId, method);</span><br><span class="line">                    // ip</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求源ip=&#123;&#125;&quot;, traceId, ipAddress);</span><br><span class="line">                    // class_method</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求方法class_method=&#123;&#125;&quot;, traceId,</span><br><span class="line">                            joinPoint.getSignature().getDeclaringTypeName() + &quot;_&quot; + joinPoint.getSignature().getName());</span><br><span class="line">                    // args[]</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求参数args=&#123;&#125;&quot;, traceId, JSON.toJSONString(parameterMap));</span><br><span class="line">                    // body</span><br><span class="line">                    log.info(&quot;traceId=&#123;&#125;，请求体body=&#123;&#125;&quot;, traceId, requestStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    /*</span><br><span class="line">                     * 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行</span><br><span class="line">                     * result的值就是被拦截方法的返回值</span><br><span class="line">                     * 需要注意,当此方法之前抛出异常,会导致接口无法被执行,对之前代码可能出现的异常,一定需要处理并不再向上抛出</span><br><span class="line">                     */</span><br><span class="line">                    result = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.info(&quot;traceId=&quot; + traceId + &quot;，异常信息exception=&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 执行时间</span><br><span class="line">            long handleTime = System.currentTimeMillis() - startTime;</span><br><span class="line">            String responseStr = result == null ? &quot;无&quot; : JSON.toJSONString(result);</span><br><span class="line">            responseStr = parameterHandle(responseStr, 10000);</span><br><span class="line">            log.info(&quot;traceId=&#123;&#125;，耗时=&#123;&#125;ms,响应结果response=&#123;&#125;&quot;, traceId, handleTime, responseStr);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param paramStr</span><br><span class="line">     * @param strlength</span><br><span class="line">     * @return</span><br><span class="line">     * @Description : 参数处理，超过指定长度字符的，只显示1000...</span><br><span class="line">     */</span><br><span class="line">    private String parameterHandle(String paramStr, int strlength) &#123;</span><br><span class="line">        if (paramStr.length() &gt; strlength) &#123;</span><br><span class="line">            paramStr = paramStr.substring(0, 1000) + &quot;...&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (paramStr.length() &gt; 10) &#123;</span><br><span class="line">            paramStr = &quot;[&quot; + paramStr + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return paramStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * @Description : 获取请求参数</span><br><span class="line">     * @param point</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String getRequestParam(ProceedingJoinPoint point) &#123;</span><br><span class="line">        Object[] paramsArray = point.getArgs();</span><br><span class="line">        String requestStr = argsArrayToString(paramsArray);</span><br><span class="line">        return requestStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求参数拼装,由于point.getArgs()获得的参数包含ServletRequest,ServletResponse等参数,需要在Json转换处理时特别注意</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String argsArrayToString(Object[] args) &#123;</span><br><span class="line">        Object[] paramsArray = new Object[args.length];</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            if (args[i] instanceof ServletRequest || args[i] instanceof ServletResponse || args[i] instanceof MultipartFile) &#123;</span><br><span class="line">                // ServletRequest不能序列化，从入参里排除，否则报异常：java.lang.IllegalStateException: It is illegal to call this method if the current request is not in asynchronous mode (i.e. isAsyncStarted() returns false)</span><br><span class="line">                // ServletResponse不能序列化 从入参里排除，否则报异常：java.lang.IllegalStateException: getOutputStream() has already been called for this response</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            paramsArray[i] = args[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String params = &quot;&quot;;</span><br><span class="line">        if (paramsArray != null &amp;&amp; paramsArray.length &gt; 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                params = JSONObject.toJSONString(paramsArray);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                params = paramsArray.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return params.trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记录浏览器访问路径,仅当上下游项目开启链路跟踪时可用</span><br><span class="line">     *</span><br><span class="line">     * @param tracer</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String extractTraceId(Tracer tracer) &#123;</span><br><span class="line">        Span span = tracer.currentSpan();</span><br><span class="line">        Long parentId = span.context().parentIdAsLong();</span><br><span class="line">        String traceId = (span == null ? null : String.valueOf(parentId));</span><br><span class="line">        if (traceId == null || traceId.isEmpty()) &#123;</span><br><span class="line">            traceId = &quot;[NoClientTraceId]&quot; + UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return traceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取客户端IP</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line"></span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip != null &amp;&amp; ip.equalsIgnoreCase(&quot;0:0:0:0:0:0:0:1&quot;)) &#123;</span><br><span class="line">            ip = &quot;127.0.0.1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&apos;,&apos;分割</span><br><span class="line">         * &quot;***.***.***.***&quot;.length() = 15</span><br><span class="line">         */</span><br><span class="line">        if(ip!=null &amp;&amp; ip.length()&gt;15)&#123;</span><br><span class="line">            if(ip.indexOf(&quot;,&quot;)&gt;0)&#123;</span><br><span class="line">                ip = ip.substring(0,ip.indexOf(&quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot下动态配置文件与Enum的结合使用]]></title>
      <url>/my-blog/2019/08/19/Spring-Boot%E4%B8%8B%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8EEnum%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文记录在Spring Boot框架下,动态配置文件与Enum的结合使用的问题.</p>
<a id="more"></a>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Enum类作为枚举常量,需要从SpringBoot配置文件(*.yml)中动态获取相关属性</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>@Value注解使用</li>
<li>枚举类定义</li>
<li>动态注入的参数赋值给静态的枚举常量</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>静态变量定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class TypeConstants &#123;</span><br><span class="line"></span><br><span class="line">    public static String springbootKey = &quot;springbootKey&quot;;</span><br><span class="line"></span><br><span class="line">    public static String springbootValue;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * TODO 此处需要额外注意:</span><br><span class="line">     * 1.由于参数为静态变量,注解需要添加到属性对应的set方法上</span><br><span class="line">     * 2.IDEA等工具自动生成的set方法,会添加static的描述,必须去掉,否则无法注入</span><br><span class="line">     * 3.本静态变量需要被Spring注解扫描,需要在类上添加@Component</span><br><span class="line">     * @param springbootValue</span><br><span class="line">     * @return void</span><br><span class="line">     **/</span><br><span class="line">    @Value(&quot;$&#123;custom.springbootValue&#125;&quot;)</span><br><span class="line">    public void setSpringbootValue(String springbootValue) &#123;</span><br><span class="line">        TypeConstants.springbootValue = springbootValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * TODO 将静态变量和枚举结合使用</span><br><span class="line">     *</span><br><span class="line">     **/</span><br><span class="line">    public enum BusinessType &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 定义在配置文件中的属性</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        CUSTOM(springbootKey, springbootValue);</span><br><span class="line"></span><br><span class="line">        private String key;</span><br><span class="line">        private String value;</span><br><span class="line"></span><br><span class="line">        BusinessType(String key, String value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getValue() &#123;</span><br><span class="line">            return this.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getKey() &#123;</span><br><span class="line">            return this.key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 通过Key获取Value</span><br><span class="line">         */</span><br><span class="line">        public static String getType(String springbootKey) &#123;</span><br><span class="line">            TypeConstants.BusinessType[] types = TypeConstants.BusinessType.values();</span><br><span class="line">            for (TypeConstants.BusinessType type : types) &#123;</span><br><span class="line">                if (type.getKey().equals(springbootKey)) &#123;</span><br><span class="line">                    return type.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DemoController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/type-constants-demo&quot;)</span><br><span class="line">    public String typeConstantsDemo() &#123;</span><br><span class="line">        String value = TypeConstants.BusinessType.getType(TypeConstants.springbootKey);</span><br><span class="line">        return &quot;Value:&quot;+value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse & IDEA快捷键对比]]></title>
      <url>/my-blog/2019/08/05/Eclipse-IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<p>本文记录Eclipse &amp; IDEA快捷键对比，及IDEA智能补全的用法</p>
<a id="more"></a>

<hr>
<h3 id="Eclipse-amp-IDEA快捷键对比"><a href="#Eclipse-amp-IDEA快捷键对比" class="headerlink" title="Eclipse &amp; IDEA快捷键对比"></a>Eclipse &amp; IDEA快捷键对比</h3><p><a href="http://note.youdao.com/noteshare?id=b27d8f51b0ca4f447edcd9294a37e9ce&sub=1CE7E3C0583F4AAB847F847EE2657F1A" target="_blank" rel="noopener">整理文档</a></p>
<h3 id="Intellij-IDEA-智能补全"><a href="#Intellij-IDEA-智能补全" class="headerlink" title="Intellij IDEA 智能补全"></a>Intellij IDEA 智能补全</h3><p><a href="https://mp.weixin.qq.com/s/7MI-WNBePwK9WNHGz6DnNA" target="_blank" rel="noopener">整理文档</a></p>
]]></content>
      
        <categories>
            
            <category> IDEA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[8种常被忽视的SQL错误用法]]></title>
      <url>/my-blog/2019/08/02/8%E7%A7%8D%E5%B8%B8%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84SQL%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文记录8种常被忽视的SQL错误用法.</p>
<a id="more"></a>

<hr>
<h3 id="Sql语句的执行顺序"><a href="#Sql语句的执行顺序" class="headerlink" title="Sql语句的执行顺序"></a>Sql语句的执行顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM </span><br><span class="line">&lt;left_table&gt;</span><br><span class="line"></span><br><span class="line">ON </span><br><span class="line">&lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">&lt;join_type&gt;</span><br><span class="line"> JOIN </span><br><span class="line">&lt;right_table&gt;</span><br><span class="line"></span><br><span class="line">WHERE </span><br><span class="line">&lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line">GROUP BY </span><br><span class="line">&lt;group_by_list&gt;</span><br><span class="line"></span><br><span class="line">HAVING </span><br><span class="line">&lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line"></span><br><span class="line">DISTINCT </span><br><span class="line">&lt;select_list&gt;</span><br><span class="line"></span><br><span class="line">ORDER BY </span><br><span class="line">&lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line">LIMIT </span><br><span class="line">&lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<h3 id="LIMIT-语句"><a href="#LIMIT-语句" class="headerlink" title="LIMIT 语句"></a>LIMIT 语句</h3><p>分页查询是最常用的场景之一，但也通常也是最容易出问题的地方。比如对于下面简单的语句，一般 DBA 想到的办法是在 type, name, create_time 字段上加组合索引。这样条件排序都能有效的利用到索引，性能迅速提升。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM   operation </span><br><span class="line">WHERE  type = &apos;SQLStats&apos; </span><br><span class="line">       AND name = &apos;SlowLog&apos; </span><br><span class="line">ORDER  BY create_time </span><br><span class="line">LIMIT  1000, 10;</span><br></pre></td></tr></table></figure>

<p>好吧，可能90%以上的 DBA 解决该问题就到此为止。但当 LIMIT 子句变成 “LIMIT 1000000,10” 时，程序员仍然会抱怨：我只取10条记录为什么还是慢？</p>
<p>要知道数据库也并不知道第1000000条记录从什么地方开始，即使有索引也需要从头计算一次。出现这种性能问题，多数情形下是程序员偷懒了。</p>
<p>在前端数据浏览翻页，或者大数据分批导出等场景下，是可以将上一页的最大值当成参数作为查询条件的。SQL 重新设计如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT   * </span><br><span class="line">FROM     operation </span><br><span class="line">WHERE    type = &apos;SQLStats&apos; </span><br><span class="line">AND      name = &apos;SlowLog&apos; </span><br><span class="line">AND      create_time &gt; &apos;2017-03-16 14:00:00&apos; </span><br><span class="line">ORDER BY create_time limit 10;</span><br></pre></td></tr></table></figure>

<p>在新设计下查询时间基本固定，不会随着数据量的增长而发生变化。</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>SQL语句中查询变量和字段定义类型不匹配是另一个常见的错误。比如下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain extended SELECT * </span><br><span class="line">     &gt; FROM   my_balance b </span><br><span class="line">     &gt; WHERE  b.bpn = 14000000123 </span><br><span class="line">     &gt;       AND b.isverified IS NULL ;</span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">| Warning | 1739 | Cannot use ref access on index &apos;bpn&apos; due to type or collation conversion on field &apos;bpn&apos;</span><br></pre></td></tr></table></figure>

<p>其中字段 bpn 的定义为 varchar(20)，MySQL 的策略是将字符串转换为数字之后再比较。函数作用于表字段，索引失效。</p>
<p>上述情况可能是应用程序框架自动填入的参数，而不是程序员的原意。现在应用框架很多很繁杂，使用方便的同时也小心它可能给自己挖坑。</p>
<h3 id="关联更新、删除"><a href="#关联更新、删除" class="headerlink" title="关联更新、删除"></a>关联更新、删除</h3><p>虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。对于更新或删除需要手工重写成 JOIN。</p>
<p>比如下面 UPDATE 语句，MySQL 实际执行的是循环/嵌套子查询（DEPENDENT SUBQUERY)，其执行时间可想而知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UPDATE operation o </span><br><span class="line">SET    status = &apos;applying&apos; </span><br><span class="line">WHERE  o.id IN (SELECT id </span><br><span class="line">                FROM   (SELECT o.id, </span><br><span class="line">                               o.status </span><br><span class="line">                        FROM   operation o </span><br><span class="line">                        WHERE  o.group = 123 </span><br><span class="line">                               AND o.status NOT IN ( &apos;done&apos; ) </span><br><span class="line">                        ORDER  BY o.parent, </span><br><span class="line">                                  o.id </span><br><span class="line">                        LIMIT  1) t);</span><br></pre></td></tr></table></figure>

<p>执行计划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+</span><br><span class="line">| id | select_type        | table | type  | possible_keys | key     | key_len | ref   | rows | Extra                                               |</span><br><span class="line">+----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+</span><br><span class="line">| 1  | PRIMARY            | o     | index |               | PRIMARY | 8       |       | 24   | Using where; Using temporary                        |</span><br><span class="line">| 2  | DEPENDENT SUBQUERY |       |       |               |         |         |       |      | Impossible WHERE noticed after reading const tables |</span><br><span class="line">| 3  | DERIVED            | o     | ref   | idx_2,idx_5   | idx_5   | 8       | const | 1    | Using where; Using filesort                         |</span><br><span class="line">+----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>重写为 JOIN 之后，子查询的选择模式从 DEPENDENT SUBQUERY 变成 DERIVED，执行速度大大加快，从7秒降低到2毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UPDATE operation o </span><br><span class="line">       JOIN  (SELECT o.id, </span><br><span class="line">                            o.status </span><br><span class="line">                     FROM   operation o </span><br><span class="line">                     WHERE  o.group = 123 </span><br><span class="line">                            AND o.status NOT IN ( &apos;done&apos; ) </span><br><span class="line">                     ORDER  BY o.parent, </span><br><span class="line">                               o.id </span><br><span class="line">                     LIMIT  1) t</span><br><span class="line">         ON o.id = t.id </span><br><span class="line">SET    status = &apos;applying&apos;</span><br></pre></td></tr></table></figure>

<p>执行计划简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key   | key_len | ref   | rows | Extra                                               |</span><br><span class="line">+----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+</span><br><span class="line">| 1  | PRIMARY     |       |      |               |       |         |       |      | Impossible WHERE noticed after reading const tables |</span><br><span class="line">| 2  | DERIVED     | o     | ref  | idx_2,idx_5   | idx_5 | 8       | const | 1    | Using where; Using filesort                         |</span><br><span class="line">+----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="混合排序"><a href="#混合排序" class="headerlink" title="混合排序"></a>混合排序</h3><p>MySQL 不能利用索引进行混合排序。但在某些场景，还是有机会使用特殊方法提升性能的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM   my_order o </span><br><span class="line">       INNER JOIN my_appraise a ON a.orderid = o.id </span><br><span class="line">ORDER  BY a.is_reply ASC, </span><br><span class="line">          a.appraise_time DESC </span><br><span class="line">LIMIT  0, 20</span><br></pre></td></tr></table></figure>

<p>执行计划显示为全表扫描：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+--------+-------------+---------+---------+---------------+---------+-+</span><br><span class="line">| id | select_type | table | type   | possible_keys     | key     | key_len | ref      | rows    | Extra    </span><br><span class="line">+----+-------------+-------+--------+-------------+---------+---------+---------------+---------+-+</span><br><span class="line">|  1 | SIMPLE      | a     | ALL    | idx_orderid | NULL    | NULL    | NULL    | 1967647 | Using filesort |</span><br><span class="line">|  1 | SIMPLE      | o     | eq_ref | PRIMARY     | PRIMARY | 122     | a.orderid |       1 | NULL           |</span><br><span class="line">+----+-------------+-------+--------+---------+---------+---------+-----------------+---------+-+</span><br></pre></td></tr></table></figure>

<p>由于 is_reply 只有0和1两种状态，我们按照下面的方法重写后，执行时间从1.58秒降低到2毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM   ((SELECT *</span><br><span class="line">         FROM   my_order o </span><br><span class="line">                INNER JOIN my_appraise a </span><br><span class="line">                        ON a.orderid = o.id </span><br><span class="line">                           AND is_reply = 0 </span><br><span class="line">         ORDER  BY appraise_time DESC </span><br><span class="line">         LIMIT  0, 20) </span><br><span class="line">        UNION ALL </span><br><span class="line">        (SELECT *</span><br><span class="line">         FROM   my_order o </span><br><span class="line">                INNER JOIN my_appraise a </span><br><span class="line">                        ON a.orderid = o.id </span><br><span class="line">                           AND is_reply = 1 </span><br><span class="line">         ORDER  BY appraise_time DESC </span><br><span class="line">         LIMIT  0, 20)) t </span><br><span class="line">ORDER  BY  is_reply ASC, </span><br><span class="line">          appraisetime DESC </span><br><span class="line">LIMIT  20;</span><br></pre></td></tr></table></figure>

<h3 id="EXISTS语句"><a href="#EXISTS语句" class="headerlink" title="EXISTS语句"></a>EXISTS语句</h3><p>MySQL 对待 EXISTS 子句时，仍然采用嵌套子查询的执行方式。如下面的 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM   my_neighbor n </span><br><span class="line">       LEFT JOIN my_neighbor_apply sra </span><br><span class="line">              ON n.id = sra.neighbor_id </span><br><span class="line">                 AND sra.user_id = &apos;xxx&apos; </span><br><span class="line">WHERE  n.topic_status &lt; 4 </span><br><span class="line">       AND EXISTS(SELECT 1 </span><br><span class="line">                  FROM   message_info m </span><br><span class="line">                  WHERE  n.id = m.neighbor_id </span><br><span class="line">                         AND m.inuser = &apos;xxx&apos;) </span><br><span class="line">       AND n.topic_type &lt;&gt; 5</span><br></pre></td></tr></table></figure>

<p>执行计划显示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------------+-------+------+-----+------------------------------------------+---------+-------+---------+ -----+</span><br><span class="line">| id | select_type        | table | type | possible_keys     | key   | key_len | ref   | rows    | Extra   |</span><br><span class="line">+----+--------------------+-------+------+ -----+------------------------------------------+---------+-------+---------+ -----+</span><br><span class="line">|  1 | PRIMARY            | n     | ALL  |  | NULL     | NULL    | NULL  | 1086041 | Using where                   |</span><br><span class="line">|  1 | PRIMARY            | sra   | ref  |  | idx_user_id | 123     | const |       1 | Using where          |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | m     | ref  |  | idx_message_info   | 122     | const |       1 | Using index condition; Using where |</span><br><span class="line">+----+--------------------+-------+------+ -----+------------------------------------------+---------+-------+---------+ -----+</span><br></pre></td></tr></table></figure>

<p>去掉 exists 更改为 join，能够避免嵌套子查询，将执行时间从1.93秒降低为1毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM   my_neighbor n </span><br><span class="line">       INNER JOIN message_info m </span><br><span class="line">               ON n.id = m.neighbor_id </span><br><span class="line">                  AND m.inuser = &apos;xxx&apos; </span><br><span class="line">       LEFT JOIN my_neighbor_apply sra </span><br><span class="line">              ON n.id = sra.neighbor_id </span><br><span class="line">                 AND sra.user_id = &apos;xxx&apos; </span><br><span class="line">WHERE  n.topic_status &lt; 4 </span><br><span class="line">       AND n.topic_type &lt;&gt; 5</span><br></pre></td></tr></table></figure>

<p>新的执行计划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新的执行计划：</span><br><span class="line"></span><br><span class="line">+----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+</span><br><span class="line">| id | select_type | table | type   | possible_keys     | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+</span><br><span class="line">|  1 | SIMPLE      | m     | ref    | | idx_message_info   | 122     | const    |    1 | Using index condition |</span><br><span class="line">|  1 | SIMPLE      | n     | eq_ref | | PRIMARY   | 122     | ighbor_id |    1 | Using where      |</span><br><span class="line">|  1 | SIMPLE      | sra   | ref    | | idx_user_id | 123     | const     |    1 | Using where           |</span><br><span class="line">+----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+</span><br></pre></td></tr></table></figure>

<h3 id="条件下推"><a href="#条件下推" class="headerlink" title="条件下推"></a>条件下推</h3><p>外部查询条件不能够下推到复杂的视图或子查询的情况有：</p>
<p>1、聚合子查询； 2、含有 LIMIT 的子查询； 3、UNION 或 UNION ALL 子查询； 4、输出字段中的子查询；</p>
<p>如下面的语句，从执行计划可以看出其条件作用于聚合子查询之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM   (SELECT target, </span><br><span class="line">               Count(*) </span><br><span class="line">        FROM   operation </span><br><span class="line">        GROUP  BY target) t </span><br><span class="line">WHERE  target = &apos;rm-xxxx&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table      | type  | possible_keys | key         | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 514     | const |    2 | Using where |</span><br><span class="line">|  2 | DERIVED     | operation  | index | idx_4         | idx_4       | 519     | NULL  |   20 | Using index |</span><br><span class="line">+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>确定从语义上查询条件可以直接下推后，重写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT target, </span><br><span class="line">       Count(*) </span><br><span class="line">FROM   operation </span><br><span class="line">WHERE  target = &apos;rm-xxxx&apos; </span><br><span class="line">GROUP  BY target</span><br></pre></td></tr></table></figure>

<p>执行计划变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+</span><br><span class="line">| 1 | SIMPLE | operation | ref | idx_4 | idx_4 | 514 | const | 1 | Using where; Using index |</span><br><span class="line">+----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+</span><br></pre></td></tr></table></figure>

<p>关于 MySQL 外部条件不能下推的详细解释说明请参考以前文章： <a href="http://mysql.taobao.org/monthly/2016/07/08" target="_blank" rel="noopener">MySQL · 性能优化 · 条件下推到物化表</a></p>
<h3 id="提前缩小范围"><a href="#提前缩小范围" class="headerlink" title="提前缩小范围"></a>提前缩小范围</h3><p>先上初始 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM   my_order o </span><br><span class="line">       LEFT JOIN my_userinfo u </span><br><span class="line">              ON o.uid = u.uid</span><br><span class="line">       LEFT JOIN my_productinfo p </span><br><span class="line">              ON o.pid = p.pid </span><br><span class="line">WHERE  ( o.display = 0 ) </span><br><span class="line">       AND ( o.ostaus = 1 ) </span><br><span class="line">ORDER  BY o.selltime DESC </span><br><span class="line">LIMIT  0, 15</span><br></pre></td></tr></table></figure>

<p>该SQL语句原意是：先做一系列的左连接，然后排序取前15条记录。从执行计划也可以看出，最后一步估算排序记录数为90万，时间消耗为12秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref             | rows   | Extra                                              |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | ALL    | NULL          | NULL    | NULL    | NULL            | 909119 | Using where; Using temporary; Using filesort       |</span><br><span class="line">|  1 | SIMPLE      | u     | eq_ref | PRIMARY       | PRIMARY | 4       | o.uid |      1 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | p     | ALL    | PRIMARY       | NULL    | NULL    | NULL            |      6 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>由于最后 WHERE 条件以及排序均针对最左主表，因此可以先对 my_order 排序提前缩小数据量再做左连接。SQL 重写后如下，执行时间缩小为1毫秒左右。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM (</span><br><span class="line">SELECT * </span><br><span class="line">FROM   my_order o </span><br><span class="line">WHERE  ( o.display = 0 ) </span><br><span class="line">       AND ( o.ostaus = 1 ) </span><br><span class="line">ORDER  BY o.selltime DESC </span><br><span class="line">LIMIT  0, 15</span><br><span class="line">) o </span><br><span class="line">     LEFT JOIN my_userinfo u </span><br><span class="line">              ON o.uid = u.uid </span><br><span class="line">     LEFT JOIN my_productinfo p </span><br><span class="line">              ON o.pid = p.pid </span><br><span class="line">ORDER BY  o.selltime DESC</span><br><span class="line">limit 0, 15</span><br></pre></td></tr></table></figure>

<p>再检查执行计划：子查询物化后（select_type=DERIVED)参与 JOIN。虽然估算行扫描仍然为90万，但是利用了索引以及 LIMIT 子句后，实际执行时间变得很小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows   | Extra                                              |</span><br><span class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL          | NULL    | NULL    | NULL  |     15 | Using temporary; Using filesort                    |</span><br><span class="line">|  1 | PRIMARY     | u          | eq_ref | PRIMARY       | PRIMARY | 4       | o.uid |      1 | NULL                                               |</span><br><span class="line">|  1 | PRIMARY     | p          | ALL    | PRIMARY       | NULL    | NULL    | NULL  |      6 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">|  2 | DERIVED     | o          | index  | NULL          | idx_1   | 5       | NULL  | 909112 | Using where                                        |</span><br><span class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="中间结果集下推"><a href="#中间结果集下推" class="headerlink" title="中间结果集下推"></a>中间结果集下推</h3><p>再来看下面这个已经初步优化过的例子(左连接中的主表优先作用查询条件)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT    a.*, </span><br><span class="line">          c.allocated </span><br><span class="line">FROM      ( </span><br><span class="line">              SELECT   resourceid </span><br><span class="line">              FROM     my_distribute d </span><br><span class="line">                   WHERE    isdelete = 0 </span><br><span class="line">                   AND      cusmanagercode = &apos;1234567&apos; </span><br><span class="line">                   ORDER BY salecode limit 20) a </span><br><span class="line">LEFT JOIN </span><br><span class="line">          ( </span><br><span class="line">              SELECT   resourcesid， sum(ifnull(allocation, 0) * 12345) allocated </span><br><span class="line">              FROM     my_resources </span><br><span class="line">                   GROUP BY resourcesid) c </span><br><span class="line">ON        a.resourceid = c.resourcesid</span><br></pre></td></tr></table></figure>

<p>那么该语句还存在其它问题吗？不难看出子查询 c 是全表聚合查询，在表数量特别大的情况下会导致整个语句的性能下降。</p>
<p>其实对于子查询 c，左连接最后结果集只关心能和主表 resourceid 能匹配的数据。因此我们可以重写语句如下，执行时间从原来的2秒下降到2毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT    a.*, </span><br><span class="line">          c.allocated </span><br><span class="line">FROM      ( </span><br><span class="line">                   SELECT   resourceid </span><br><span class="line">                   FROM     my_distribute d </span><br><span class="line">                   WHERE    isdelete = 0 </span><br><span class="line">                   AND      cusmanagercode = &apos;1234567&apos; </span><br><span class="line">                   ORDER BY salecode limit 20) a </span><br><span class="line">LEFT JOIN </span><br><span class="line">          ( </span><br><span class="line">                   SELECT   resourcesid， sum(ifnull(allocation, 0) * 12345) allocated </span><br><span class="line">                   FROM     my_resources r, </span><br><span class="line">                            ( </span><br><span class="line">                                     SELECT   resourceid </span><br><span class="line">                                     FROM     my_distribute d </span><br><span class="line">                                     WHERE    isdelete = 0 </span><br><span class="line">                                     AND      cusmanagercode = &apos;1234567&apos; </span><br><span class="line">                                     ORDER BY salecode limit 20) a </span><br><span class="line">                   WHERE    r.resourcesid = a.resourcesid </span><br><span class="line">                   GROUP BY resourcesid) c </span><br><span class="line">ON        a.resourceid = c.resourcesid</span><br></pre></td></tr></table></figure>

<p>但是子查询 a 在我们的SQL语句中出现了多次。这种写法不仅存在额外的开销，还使得整个语句显的繁杂。使用 WITH 语句再次重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WITH a AS </span><br><span class="line">( </span><br><span class="line">         SELECT   resourceid </span><br><span class="line">         FROM     my_distribute d </span><br><span class="line">         WHERE    isdelete = 0 </span><br><span class="line">         AND      cusmanagercode = &apos;1234567&apos; </span><br><span class="line">         ORDER BY salecode limit 20)</span><br><span class="line">SELECT    a.*, </span><br><span class="line">          c.allocated </span><br><span class="line">FROM      a </span><br><span class="line">LEFT JOIN </span><br><span class="line">          ( </span><br><span class="line">                   SELECT   resourcesid， sum(ifnull(allocation, 0) * 12345) allocated </span><br><span class="line">                   FROM     my_resources r, </span><br><span class="line">                            a </span><br><span class="line">                   WHERE    r.resourcesid = a.resourcesid </span><br><span class="line">                   GROUP BY resourcesid) c </span><br><span class="line">ON        a.resourceid = c.resourcesid</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据库编译器产生执行计划，决定着SQL的实际执行方式。但是编译器只是尽力服务，所有数据库的编译器都不是尽善尽美的。</p>
<p>上述提到的多数场景，在其它数据库中也存在性能问题。了解数据库编译器的特性，才能避规其短处，写出高性能的SQL语句。</p>
<p>程序员在设计数据模型以及编写SQL语句时，要把算法的思想或意识带进来。</p>
<p>编写复杂SQL语句要养成使用 WITH 语句的习惯。简洁且思路清晰的SQL语句也能减小数据库的负担 。</p>
<p>本文转载自，并未做任何调整</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/MfxvIfAbDWYk1TU0jTpllg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MfxvIfAbDWYk1TU0jTpllg</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String.intern()来优化使用Redis]]></title>
      <url>/my-blog/2019/08/02/String-intern-%E6%9D%A5%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8Redis/</url>
      <content type="html"><![CDATA[<p>本文记录使用String.intern()来优化使用Redis作为查询缓存的场景.</p>
<a id="more"></a>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在一个接口中，该接口被多个线程并发访问，该接口主要做了以下工作：查询的时候是根据广告的类型查询符合该类型的广告，如果查询到广告，那么就返回该类型广告列表。同时，由于请求量比较的大，为了增加查询速度，减轻数据库的负担，我们在该层加入Redis。</p>
<p>我们会这样做，首先，我们去Redis查询该类型的广告，如果存在那么就直接返回，如果不存在，那么我们需要为该广告类型加锁，进行锁定，然后进行二次查询Redis（二次判空，保证查询排队的线程，只要有一个查询到了，那么其他的就不用查库了），然后查询数据库，再存入到Redis 中，返回即可。其他的线程，如果当时在排队，那么在二次判空的时候就可以拿到值，其他的则在第一次查询Redis中直接拿到了值。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>但是，要注意，在接口中我们是在线程内部的，我们锁定的只是一个字符串对象。首先，相同值的字符串，也可能是不同的对象；其次，该场景下字符串为局部变量（需注意是字面量赋值还是new对象），在线程内部，由于线程的栈封闭性，我们锁定的该字符串值，其他线程并不知道。</p>
<p>所以，我们需要一种策略，值相同的字符串就是一个对象，同时又是线程可见性的，那么字符串常量池就是一个很好的媒介，我们可以使用intern方法得到字符串常量池的引用，这样就保证了字符串值相同，那么就是一个对象，同时又是线程可见的。</p>
<p>但是，我们最好还是不要直接用字符串的intern方法，首先在Jdk1.6以及之前，字符串常量池是存储在永久代中的，也就是方法区中的，如果频繁使用该方法，那么就会造成该区域内存占有过大，造成垃圾收集器的GC，从而影响程序的运行。Java有一个很好的工具库， Guava ，其中封装了很多的工具类，其中很多平时都很常用，其中就有一个类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interner&lt;String&gt; pool = Interners.newWeakInterner();</span><br></pre></td></tr></table></figure>

<p>该类对 intern 做了很多的优化，使用弱引用包装了你传入的字符串类型，所以，这样就不会对内存造成较大的影响，可以使用该类的 pool.intern(str)来进行对字符串intern。 这样就解决了内存的问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>伪码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (redis 存在) &#123;</span><br><span class="line">    // 直接return;</span><br><span class="line">&#125; else &#123; </span><br><span class="line">    // 不存在</span><br><span class="line">    Interner&lt;String&gt; pool = Interners.newWeakInterner();</span><br><span class="line">    synchronized (pool.intern(str)) &#123;</span><br><span class="line">        if(redis 存在)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 查库，入redis,返回</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>synchronized关键字针对共享变量，方法，类加锁；针对局部变量或者对象，无法起到锁的效果</p>
<p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">深入理解String#intern</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git使用技巧]]></title>
      <url>/my-blog/2019/07/29/Git%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="Git使用技巧"><a href="#Git使用技巧" class="headerlink" title="Git使用技巧"></a>Git使用技巧</h2><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&gt;1. 创建远程分枝</span><br><span class="line">    创建分支       git branch 分支名</span><br><span class="line">    推送到远程      git push origin 分支名</span><br><span class="line">    </span><br><span class="line">&gt;2. 第一次拉取远程分支（本地没有）</span><br><span class="line">    git fetch origin 远程分枝名:本地分枝名   </span><br><span class="line">    例如: git fetch origin feature/v1.0:feature/v1.0</span><br><span class="line">    </span><br><span class="line">&gt;3. 提交代码</span><br><span class="line">    1.git add .</span><br><span class="line">    2.git commit -m &quot;注释&quot;   </span><br><span class="line">    3.git pull</span><br><span class="line">    是否有冲突</span><br><span class="line">        4.1.有冲突解决后，回到第一步 git add . ,再执行一遍步骤</span><br><span class="line">        4.2.没有冲突，继续第5步</span><br><span class="line">    5.git push</span><br><span class="line">    </span><br><span class="line">&gt;4. 其他命令</span><br><span class="line">     git命令   任何操作都需要以 git 命令为开头</span><br><span class="line">     本地操作：</span><br><span class="line">     git init  初始化一个本地仓库  新建为 master主分支</span><br><span class="line">     git status  查看当前分支状态</span><br><span class="line">     git add  &lt;文件名&gt;   将文件更改添加到分支状态中 相当于文件等待被提交</span><br><span class="line">     git commit -m &lt;&quot;描述信息&quot;&gt;  提交并添加描述信息</span><br><span class="line">     git branch  查看分支   前面带*号的为当前所在分支</span><br><span class="line">     git branch &lt;分支名称&gt;  新建分支</span><br><span class="line">     git checkout &lt;分支名&gt;  切换分支</span><br><span class="line">     git checkout -b &lt;分支名&gt;  新建分支并切换到此分支</span><br><span class="line">     git merge &lt;分支名&gt;   将指定分支名合并到当前分支  一般为切换到主分支使用此命令</span><br><span class="line">     git merge --no-ff -m &quot;提交描述&quot; &lt;分支名&gt;   合并分支并提交</span><br><span class="line">     git branch -d &lt;分支名&gt;  有新建分支，那肯定有删除分支，假如这个分支新建错了，或者a分支的代码已经顺利合并到 master 分支来了，那么a分支没用了，需要删除，这个时候执行 git branch -d a 就可以把a分支删除了</span><br><span class="line">     git branch -D &lt;分支名&gt;  强制删除分支，不管分支是否有未提交合并的代码</span><br><span class="line"></span><br><span class="line">     git tag 查看所有标签</span><br><span class="line">     git tag &lt;标签名&gt; 在当前状态下新建一个标签，可用来当作版本号使用</span><br><span class="line">     git tag -a &lt;标签名称&gt; -m &lt;&quot;标签描述&quot;&gt; &lt;提交id&gt;  在指定的提交状态下新建一个标签</span><br><span class="line">     git show &lt;标签名称&gt;   查看标签的详情</span><br><span class="line">     git tag -d &lt;标签名&gt; 删除标签</span><br><span class="line">     git push origin &lt;标签名&gt;   推送标签到远程仓库</span><br><span class="line">     git push origin --tags  推送所有未推送的标签</span><br><span class="line">     git push origin :refs/tags/&lt;标签名&gt;   删除远程标签，本地要先删除后才可以</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     git checkout &lt;标签名&gt; 切换到标签名指定的状态</span><br><span class="line">     git diff &lt;文件名&gt; 查看文件修改内容</span><br><span class="line">     </span><br><span class="line">     git log      查看提交日志   --pretty=oneline  此参数减少输出信息  穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">     git reflog   要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</span><br><span class="line">     git log --graph --pretty=oneline --abbrev-commit   查看分支合并图</span><br><span class="line">     git reset --hard &lt;HEAD^||提交ID&gt; 穿梭到指定提交版本</span><br><span class="line">     HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</span><br><span class="line">     </span><br><span class="line">     git checkout -- &lt;文件名&gt;  将指定的文件恢复到最近一次 commit或add操作时候的状态</span><br><span class="line">     git reset HEAD &lt;文件名&gt;   将指定的文件从暂存区的修改撤销掉（unstage），重新放回工作区</span><br><span class="line">     git rm &lt;文件名&gt;       删除指定的文件</span><br><span class="line">     </span><br><span class="line">     git stash  把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span><br><span class="line">     git stash list 查看暂存状态</span><br><span class="line">     git stash apply 恢复暂存状态</span><br><span class="line">     git stash drop  删除暂存状态</span><br><span class="line">     git stash pop   恢复并删除暂存状态</span><br><span class="line">     git stash apply &lt;stash@&#123;0&#125;&gt;  恢复指定的暂存状态</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     远程仓库操作:</span><br><span class="line">     git clone &lt;远程地址&gt;  从远征仓库拷贝过来代码，相当于建立本地分支</span><br><span class="line">     git pull 将最新的提交从远程仓库抓取下来</span><br><span class="line">     git push  将本地修改后的代码提交到远程仓库</span><br><span class="line">     git push &lt;远程仓库名，默认origin&gt; &lt;本地分支名&gt;  将指定的分支推送到远程分支上</span><br><span class="line">     </span><br><span class="line">     git remote -v 查看远程仓库  -v 为详细信息</span><br><span class="line">     </span><br><span class="line">     git checkout -b &lt;本地支分支名&gt; &lt;远程仓库名，默认origin&gt;/&lt;远程支分支名&gt; 拉取远程主分支下的支分支。。。</span><br><span class="line">     git branch --set-upstream &lt;本地支分支名&gt; &lt;远程仓库名，默认origin&gt;/&lt;远程支分支名&gt;  将本地分支与远程指定的分支关联起来</span><br><span class="line">     </span><br><span class="line">     //以下为先有本地库，再建立远程库操作所用的命令</span><br><span class="line">     git remote add origin &lt;URL地址&gt; 本地库与远征库关联</span><br><span class="line">     git push -u origin master 关联后，使用命令第一次推送master分支的所有内容，   -u参数为推送当前分支所有内容</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Windows下配置多个Git提交账户]]></title>
      <url>/my-blog/2019/07/24/%E5%9C%A8Windows%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGit%E6%8F%90%E4%BA%A4%E8%B4%A6%E6%88%B7/</url>
      <content type="html"><![CDATA[<p>本文记录在Windows下配置两个github账号的过程.</p>
<a id="more"></a>
<hr>
<ol>
<li>生成并部署SSH Key</li>
</ol>
<p>安装好Git客户端后，打开git bash，输入以下命令生成user1的SSH Key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;user1@email.com&quot;</span><br></pre></td></tr></table></figure>

<p>在当前用户的.ssh目录下(C:\Users\lenovo\.ssh)会生成id_rsa私钥文件和id_rsa.pub公钥文件，将id_rsa.pub中的内容添加至user1的github中。然后在git bash中输入以下命令测试该用户的SSH密钥是否生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>==注：若提示‘ssh: connect to host github.com port 22: Connection timed out’，证明远端仓库拒绝匿名认证。若连接成功则提示‘Hi user1! You’ve successfully authenticated, but GitHub does not provide shell access.’==</p>
<p>接着生成user2的密钥，注意不能再使用默认的文件名id_rsa，否则会覆盖之前密钥文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa2 -C &quot;user2@email.com&quot;</span><br></pre></td></tr></table></figure>

<p>再将该用户的公钥文件添加至github中。测试user2的ssh连接时需要指定密钥文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com -i ~/.ssh/id_rsa2</span><br></pre></td></tr></table></figure>

<hr>
<ol start="2">
<li>配置config文件</li>
</ol>
<p>在.ssh目录下创建一个config文本文件，每个账号配置一个Host节点。主要配置项说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Host            别名</span><br><span class="line">HostName        主机名</span><br><span class="line">Port            端口</span><br><span class="line">User            用户名</span><br><span class="line">IdentityFile    密钥文件的路径</span><br><span class="line">IdentitiesOnly  只接受SSH Key 登录</span><br><span class="line">PreferredAuthentications publickey  强制使用Public Key验证</span><br><span class="line"></span><br><span class="line"># 配置user1 </span><br><span class="line">Host u1.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User user1</span><br><span class="line"></span><br><span class="line"># 配置user2</span><br><span class="line">Host u2.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">IdentityFile C:\\Users\\lenovo\\.ssh\\id_rsa2</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User user2</span><br></pre></td></tr></table></figure>

<p>再通过终端测试SSH Key是否生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@u1.github.com</span><br><span class="line">ssh -T git@u2.github.com</span><br></pre></td></tr></table></figure>

<hr>
<ol start="3">
<li>配置用户名及邮箱</li>
</ol>
<p>如果之前配置过全局的用户名和邮箱，可以按需选择是否取消全局配置。若取消，需要在各仓库下单独配置相应的用户名和邮箱；反之仅需在需要单独用户的仓库下进行配置，未配置的仓库按照全局配置获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 全局配置（任意位置执行）</span><br><span class="line">$ git config --global user.name &quot;github&apos;s Name&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;github@xx.com&quot;</span><br><span class="line"></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 取消全局配置</span><br><span class="line">git config --global --unset user.name</span><br><span class="line"></span><br><span class="line">git config --global --unset user.email</span><br><span class="line"></span><br><span class="line"># 局部配置（在下载的项目根目录执行）</span><br><span class="line">$ git config user.name &quot;gitlab&apos;s Name&quot;</span><br><span class="line"></span><br><span class="line">$ git config user.email &quot;gitlab@xx.com&quot;</span><br></pre></td></tr></table></figure>

<p>==注：配置加载的优先策略为先执行局部配置读取，再进行全局配置读取==</p>
<hr>
<ol start="4">
<li>配置SSH认证私钥<br>通过puttygen工具（TortoiseGit）生成*.ppk文件,以支持pageant工具(TortoiseGit)认证私钥</li>
</ol>
<hr>
<ol start="5">
<li>注意事项<br>由于本人安装了TortoiseGit,其默认SSH工具为TortoiseGitPlink.exe，且配置了系统环境变量GIT_SSH指向TortoiseGitPlink.exe。在执行hexo d 指令时，默认该SSH工具进行链接，导致失败。后删除系统环境变量，且配置TortoiseGit的SSH工具为Git下的\usr\bin\ssh.exe，解决提交错误的问题</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
